Name: Hannah Bernthal

| Date   |      Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Update |
|:-------|:---------------:|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Oct 14 |     5pm-6pm     |                                                                                                                  I think a simple way to start this for V1 would be to think about coding this problem to use simple loops and substring checks. You would start by looping through each position in the DNA sequence, and at every position, you’d check if the STR begins there by comparing a substring of the sequence to the STR. If it matches, you then keep moving forward by the length of the STR and continue counting how many times in a row it repeats. Once the streak ends, you record that count and compare it to the maximum streak you’ve found so far. If it’s larger, you update your maximum. Then you continue scanning the sequence from the next position until the entire DNA sequence has been checked. By the end, you’ll have stored the highest repeat count of the STR anywhere in the sequence. |
| Oct 14 |  10pm-10:30pm   |                                                                                                                                                                                                                                                                                                                                                                          I implemented my idea that I described. When I started ipmlemementing this, the first challenge was figuring out how to check for repeats without getting lost in the long DNA string. I set up a loop to go through each position, and at first I kept forgetting to reset the counter after a streak ended, which gave me wrong answers. Once I fixed that, I realized I also needed to move forward by the length of the STR during a streak so overlapping parts wouldn't count. It took a bit of trial and error but passed all checks at the end! |
| Oct 15 |  11:15am-11:55  |                                                                                                                                                                                                                                                    In class today, I started thinking about better ways to approach this problem. I believe the current run time would be O(sequence length * str length), so I want to try to optimize this somehow. I think one way to help would be to check to see if the first letter of the given substring matches the first letter of str. If I see immediately that they aren't equal, I could move on to the next part without checking. I implemented that and it minorly improved the runtime but definitely did not make a categorical improvement. I am excited to learn about the better way to solve this because I really struggled to think of something different that works. |
| Oct 21 |   6pm-6:25pm    |                                                                                                                                                                                                                                                                                            During this time, I thought through how the has function would work. I studied the slides that were posted and started to understand Horner's method as well as the Rabin-Karp fingerprinting algorithm. I think that I am going to have a hash function which gets the initial hash, and then I am also going to create a slide function which will use the previous hash in order to get the new hash. Also, I am still thinking about whether you want to skip past the length of STR when you get a math or if you want to slide your way over. My guess is that skipping will be faster but I am going to try to implement both. |
| Oct 21 |  6:25pm-7:10pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                               Ok so I implemented both the hash and the slide functions and I think they will work. However, I did not put any %s in because the radix is so small that I don't think I will need it. At the end if I have time, I am going to generalize to 256, in which case I would need the %s. This is ebcause the hash values could grow to be much much larger, so I need to prevent overflow through the modulus function and a large prime number to prevent overflow. |
| Oct 24 | 11:40am-11:55am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  I started focusing on what I need to do in STRCount which is the actual stuff that makes the code run. I think that my hashing functions work well, so now I need to find a way to actually index through the sequence and compare the hashes. Also, I am worried about the edge case that may appear when letters overlap because I honestly have zero clue how to solve that. |
| Oct 26 |   6pm-6:40pm    |                                                                                                                                                                                                                                                                       I built findMatches which returns the number of matches in a given sequence. I also had do finish implementing the rest of STRcount to get it to work. At first I had the for loop going all the way up to the length of the sequence with an if statement in the loop making sure it doesn't go out of bounds, but then I realized that I could just make the actual length of the for loop shorter meaning that I dont even have to check for that in the loop itself. Once I finished that, I tested my code and it works for the first three test cases and then took wayyyyy too long on the "largest" test so I started focusing on how to fix that. |
| Oct 26 |  6:40pm-7:30pm  |                                                                                                                                                                                                                                                                                   This honestly confused me so much. I spent almost 40 mintues trying to move things around, test removing different parts of the code, debugging, etc. I eventually realized that I was sliding the hash but only updating the index of the for loop by 1 meaning that they were out of sync. Once I realized that, I added in the line that updates i to be one ahead of the previous window. I thought this would work, but it didn't, so I debugged some more and realized I needed to update i to be ahead of the window but then subtract 1 to account for the natural indexing of the loop. After this, I started to code in test Tricky. |
| Oct 26 |   8pm-8:35pm    |  I coded in test tricky just by kind of brute forcing it and now it works. The first thing I did was check if the index right after the current window was equal to the first letter of the STR. I did this because the instances where the edge case was occuring is the first time there isn't a STR right after a string of there being some. When I did that, it was going out of bounds for the largest test, so I added a condition to the if statement to make sure that i was in bounds to test for this edge case. Then, inside of the loop, I did the math to figure out that i needs to be "unupdated" from the previous slide forward in a sense. To do this, I had to subtract one less than what I had just previously added. Once I did that, I passed all of the test cases. However, I still think that there are definitely ways that I could improve this code so I am going to try to work on that tomorrow. |


To add a new row to the table, click into a cell and then hit shift-enter.